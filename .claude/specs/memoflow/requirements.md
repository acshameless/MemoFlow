# MemoFlow 需求规格说明书

## 引言

MemoFlow（记忆流）是一个基于 Python 3 构建的命令行/TUI 工作流管理工具，为会议、笔记、任务和邮件提供统一管理。系统遵循核心理念："快速捕获、清晰组织、经常回顾、有效执行"。

系统使用 Markdown 作为存储格式，Git 用于版本控制和历史追踪，Johnny.Decimal 用于结构化组织，并包含 Nebula Graph 接口以支持未来的 LLM 知识交互。MemoFlow 的两个关键增强特性是：(1) 类似 Git 的短哈希寻址系统，便于文件引用；(2) GitHub Actions 集成，实现基于云端的自动化和备份。

---

## 需求

### 1. 核心基础设施

#### 1.1 双重索引系统

**用户故事**：作为用户，我希望使用层级分类 ID 和永久短哈希来引用文件，这样我可以在逻辑上组织文件，同时保持稳定的引用，即使文件被移动或重命名也不会失效。

**验收标准**：
- **当**创建文件时，**则**系统必须生成唯一的 6 位十六进制短哈希（例如：`7f9a2b`）并将其存储在文件的 frontmatter 中作为 `uuid`
- **当**创建文件时，**则**系统必须分配一个临时的 Johnny.Decimal ID（例如：`HANK-00.01`）并将其存储在文件的 frontmatter 中作为 `id`
- **当**文件移动到新位置时，**则**系统必须更新 `id` 字段以反映新的 Johnny.Decimal 路径，**但**`uuid` 字段必须保持不变
- **当**用户通过短哈希引用文件时，**则**系统必须能够定位文件，无论其在目录结构中的当前位置如何
- **当**系统生成短哈希时，**则**系统必须确保在整个仓库中所有现有文件之间的唯一性

#### 1.2 Schema 配置

**用户故事**：作为用户，我希望通过配置文件自定义区域和类别结构，这样系统可以适应我的组织需求，而无需硬编码约束。

**验收标准**：
- **当**系统初始化时，**则**如果存在 `schema.yaml`，系统必须从中加载 schema 配置
- **如果**`schema.yaml` 不存在，**则**系统必须创建包含预定义区域和类别的默认 schema
- **当**用户修改 `schema.yaml` 时，**则**系统必须在应用更改之前验证 schema 结构
- **当**schema 定义区域和类别时，**则**系统必须使用这些定义来确定有效的 Johnny.Decimal 路径
- **当**用户尝试使用无效的区域或类别 ID 时，**则**系统必须拒绝操作并提供错误消息

#### 1.3 Markdown 文件结构

**用户故事**：作为用户，我希望文件以 Markdown 格式存储，并包含结构化的 frontmatter，这样内容既人类可读又机器可解析。

**验收标准**：
- **当**创建文件时，**则**它必须包含 YAML frontmatter，包含以下必需字段：`uuid`、`id`、`type`、`title`、`status`、`created_at`
- **当**创建文件时，**则**它必须支持可选字段：`due_date`、`tags`
- **当**读取文件时，**则**系统必须解析 frontmatter 并验证必需字段是否存在
- **如果**frontmatter 缺失或格式错误，**则**系统必须优雅地处理错误并提供清晰的错误消息
- **当**创建文件时，**则**内容正文必须存储在 frontmatter 分隔符下方

---

### 2. 快速捕获

#### 2.1 快速捕获命令

**用户故事**：作为用户，我希望使用简单命令快速捕获内容，这样我可以在不中断工作流的情况下记录信息。

**验收标准**：
- **当**用户执行 `mf capture -t <type> "content"` 时，**则**系统必须创建包含所提供内容的新 Markdown 文件
- **当**通过捕获创建文件时，**则**它必须放置在 `00-Inbox` 目录中
- **当**创建文件时，**则**系统必须自动生成并分配短哈希（`uuid`）和临时 ID（`id`）
- **当**创建文件时，**则**系统必须将 `status` 默认设置为 "open"
- **当**创建文件时，**则**系统必须将 `created_at` 设置为当前时间戳
- **当**创建文件时，**则**系统必须自动创建遵循 Angular Commit Convention 的 Git 提交，消息格式为：`feat(new): capture ...`
- **当**提供 `-t` 类型参数时，**则**系统必须验证类型是否为以下之一：`meeting`、`note`、`task`、`email`
- **如果**类型无效，**则**系统必须拒绝命令并显示错误消息

#### 2.2 自动 Git 集成

**用户故事**：作为用户，我希望所有文件操作都自动提交到 Git，这样我可以在无需手动 Git 命令的情况下拥有完整的更改历史。

**验收标准**：
- **当**创建文件时，**则**系统必须自动为新文件执行 `git add`
- **当**创建文件时，**则**系统必须自动执行 `git commit`，并附带适当的提交消息
- **当**修改文件时，**则**系统必须自动创建 Git 提交
- **当**移动文件时，**则**系统必须自动创建 `refactor` 类型的 Git 提交
- **当**更新文件内容时，**则**系统必须自动创建 `docs` 类型的 Git 提交
- **当**标记文件为完成时，**则**系统必须自动创建 `feat` 类型的 Git 提交
- **当**创建 Git 提交时，**则**提交消息必须包含文件的短哈希，格式为：`type(hash): description`
- **如果**仓库中未初始化 Git，**则**系统必须在执行操作之前初始化 Git
- **如果**Git 操作失败，**则**系统必须优雅地处理错误并通知用户

---

### 3. 清晰组织

#### 3.1 基于哈希的文件移动

**用户故事**：作为用户，我希望使用短哈希而不是长 ID 来移动文件，这样我可以快速组织文件，而无需记忆复杂的路径。

**验收标准**：
- **当**用户执行 `mf move <hash> <old_path> <new_path>` 时，**则**系统必须使用提供的哈希定位文件（支持部分哈希匹配）
- **当**多个文件匹配部分哈希时，**则**系统必须拒绝操作并显示所有匹配的文件
- **当**用户提供 `old_path` 时，**则**系统必须验证提供的旧路径是否与文件的实际路径（frontmatter 中的 `id` 字段或文件当前位置）匹配
- **如果**提供的 `old_path` 与文件实际路径不匹配，**则**系统必须拒绝操作并显示错误消息
- **当**移动文件时，**则**系统必须使用用户提供的 `old_path` 作为旧路径记录
- **当**移动文件时，**则**系统必须更新文件 frontmatter 中的 `id` 字段以反映新的 Johnny.Decimal 路径
- **当**移动文件时，**则**系统必须将文件物理移动到新目录位置
- **当**移动文件时，**则**系统必须自动创建 Git 提交，消息为：`refactor(<hash>): move from <old_path> to <new_path>`
- **当**用户提供无效的目标路径时，**则**系统必须根据 schema 验证路径，如果无效则拒绝
- **如果**目标目录不存在，**则**系统必须在移动文件之前创建它

#### 3.2 Schema 管理

**用户故事**：作为用户，我希望管理区域和类别的定义，这样我可以随着需求的变化调整组织结构。

**验收标准**：
- **当**用户修改 schema 配置时，**则**系统必须验证新的 schema 结构
- **当**更新 schema 时，**则**系统必须确保现有文件仍然可访问
- **当**用户尝试使用 schema 命令时，**则**系统必须提供清晰的操作结果反馈
- **如果**schema 修改会使现有文件路径无效，**则**系统必须在应用更改之前警告用户

---

### 4. 经常回顾

#### 4.1 列表视图

**用户故事**：作为用户，我希望以树形格式查看当前目录结构，这样我可以理解文件的组织方式。

**验收标准**：
- **当**用户执行 `mf list` 时，**则**系统必须显示显示区域、类别和文件的树形结构
- **当**显示列表时，**则**系统必须显示每个文件的 Johnny.Decimal ID 和短哈希
- **当**显示列表时，**则**系统必须以可读格式显示文件元数据（类型、状态、标题）
- **当**列表很大时，**则**系统应该支持分页或过滤选项

#### 4.2 状态视图

**用户故事**：作为用户，我希望查看工作流状态的摘要，这样我可以快速评估需要关注的事项。

**验收标准**：
- **当**用户执行 `mf status` 时，**则**系统必须显示：
  - Inbox（`00-Inbox`）中的文件数量
  - 状态为 `open` 的文件数量
  - 显示短哈希及其对应文件的哈希到文件映射表
- **当**显示状态时，**则**系统必须根据当前文件系统状态计算这些指标
- **当**显示哈希映射时，**则**系统必须显示哈希和文件的当前位置/ID

#### 4.3 时间轴视图

**用户故事**：作为用户，我希望查看活动的时间轴，这样我可以回顾我一段时间内的工作内容。

**验收标准**：
- **当**用户请求时间轴视图时，**则**系统必须解析 Git 日志条目
- **当**显示时间轴时，**则**系统必须按时间顺序渲染条目
- **当**显示时间轴时，**则**系统必须显示提交消息、时间戳和关联的文件哈希
- **当**解析 Git 日志时，**则**系统必须处理遵循 Angular Commit Convention 的提交
- **当**显示时间轴时，**则**系统应该支持按日期范围、类型或哈希过滤

#### 4.4 日历视图

**用户故事**：作为用户，我希望在日历上查看任务和事件，这样我可以看到到期事项并相应地进行计划。

**验收标准**：
- **当**用户请求日历视图时，**则**系统必须扫描所有文件中的 frontmatter 中的 `due_date` 字段
- **当**显示日历时，**则**系统必须在相应的日期上渲染带有到期日的文件
- **当**显示日历时，**则**系统必须显示文件标题、哈希和状态
- **当**文件没有 `due_date` 时，**则**它不得出现在日历视图中
- **当**显示日历时，**则**系统应该突出显示过期项目

---

### 5. 有效执行

#### 5.1 任务完成

**用户故事**：作为用户，我希望使用短哈希标记任务为完成，这样我可以高效地跟踪进度。

**验收标准**：
- **当**用户执行 `mf finish <hash>` 时，**则**系统必须使用提供的哈希定位文件
- **当**文件被标记为完成时，**则**系统必须将 frontmatter 中的 `status` 字段更新为 "done"
- **当**文件被标记为完成时，**则**系统必须自动创建 Git 提交，消息为：`feat(<hash>): mark as done`
- **如果**文件已经标记为 "done"，**则**系统必须通知用户
- **如果**多个文件匹配部分哈希，**则**系统必须拒绝操作并显示所有匹配项

#### 5.2 任务聚合

**用户故事**：作为用户，我希望在单个列表中查看所有开放任务，这样我可以专注于需要完成的工作。

**验收标准**：
- **当**用户请求开放任务时，**则**系统必须扫描所有状态为 `open` 的文件
- **当**显示开放任务时，**则**系统必须显示文件标题、哈希、类型、到期日（如果存在）和位置
- **当**显示开放任务时，**则**系统必须按到期日（如果存在）或创建日期排序
- **当**任务有 `due_date` 时，**则**系统应该突出显示过期任务

---

### 6. 自动化与云端集成

#### 6.1 GitHub Actions 集成

**用户故事**：作为系统管理员，我希望 GitHub Actions 自动执行日常操作，这样系统可以在无需手动干预的情况下提供主动协助。

**验收标准**：
- **当**系统设置为自动化时，**则**它必须包含 GitHub Actions 工作流文件（`.github/workflows/*.yml`）
- **当**触发工作流时，**则**它必须能够在仓库上下文中执行 MemoFlow 命令
- **如果**需要身份验证，**则**系统必须支持 GitHub secrets 以进行安全的凭据管理

#### 6.2 晨间唤醒工作流

**用户故事**：作为用户，我希望每天早上收到每日焦点文档，这样我可以以清晰的优先级开始新的一天。

**验收标准**：
- **当**晨间工作流运行（每天 8:00 定时）时，**则**系统必须扫描所有文件中 `due_date` 匹配今天日期的任务
- **当**晨间工作流运行时，**则**系统必须生成包含以下内容的 `Daily_Focus.md` 文件：
  - 今天到期的任务列表
  - 开放任务摘要
  - 任何相关提醒
- **当**生成 `Daily_Focus.md` 时，**则**系统必须自动提交并将其推送到仓库
- **当**工作流完成时，**则**系统必须优雅地处理错误并记录任何问题

#### 6.3 晚间复盘工作流

**用户故事**：作为用户，我希望每天晚上收到每日回顾文档，这样我可以反思一天的成就。

**验收标准**：
- **当**晚间工作流运行（每天 23:00 定时）时，**则**系统必须分析当天来自 Git 日志的条目
- **当**晚间工作流运行时，**则**系统必须生成包含以下内容的 `Daily_Review.md` 文件：
  - 今天提交的摘要
  - 创建、修改或完成的文件统计
  - 工作模式分析
- **当**生成 `Daily_Review.md` 时，**则**系统必须自动提交并将其推送到仓库
- **当**解析 Git 日志时，**则**系统必须正确识别当天的提交

#### 6.4 CI 命令接口

**用户故事**：作为系统管理员，我希望有一个用于 CI/CD 执行的专用命令，这样 GitHub Actions 可以可靠地与 MemoFlow 交互。

**验收标准**：
- **当**执行 `mf ci` 时，**则**系统必须检测上下文（根据时间或参数判断是晨间还是晚间）
- **当**`mf ci` 在晨间上下文中运行时，**则**它必须执行晨间唤醒工作流逻辑
- **当**`mf ci` 在晚间上下文中运行时，**则**它必须执行晚间复盘工作流逻辑
- **当**`mf ci` 执行时，**则**它必须在适合 CI 环境的非交互模式下运行
- **如果**`mf ci` 遇到错误，**则**它必须为 CI 系统退出适当的错误代码

---

### 7. 知识图谱集成

#### 7.1 图谱同步

**用户故事**：作为用户，我希望将 MemoFlow 数据同步到 Nebula Graph 数据库，这样我可以利用基于图的知识关系进行未来的 LLM 交互。

**验收标准**：
- **当**用户执行 `mf sync-graph` 时，**则**系统必须连接到配置的 Nebula Graph 实例
- **当**同步到图谱时，**则**系统必须为每个 Markdown 文件创建一个节点，使用文件的短哈希作为节点 ID
- **当**同步到图谱时，**则**系统必须提取并创建以下内容的边：
  - 文件内容中的 `[[wikilink]]` 模式
  - 文件内容或 frontmatter 中的 `#hashtag` 模式
  - 目录层次关系（基于 Johnny.Decimal 结构的父子关系）
- **当**节点已存在于图谱中时，**则**系统必须更新它而不是创建重复项
- **当**同步时，**则**系统必须保留短哈希作为节点标识符以确保稳定性
- **如果**Nebula Graph 连接失败，**则**系统必须优雅地处理错误并提供清晰的反馈
- **当**同步时，**则**系统必须支持增量更新（仅同步自上次同步以来更改的文件）

---

### 8. 技术约束

#### 8.1 平台要求

**验收标准**：
- **当**系统运行时，**则**它必须需要 Python 3（需指定最低版本）
- **当**系统初始化时，**则**它必须检查必需的依赖项，如果缺失则提供清晰的错误消息
- **当**执行 Git 操作时，**则**系统必须使用 `gitpython` 库或等效库
- **当**系统运行时，**则**它必须支持命令行和 TUI 接口

#### 8.2 数据完整性

**验收标准**：
- **当**文件操作中途失败时，**则**系统不得使仓库处于不一致状态
- **当**检测到短哈希冲突时，**则**系统必须通过生成新哈希或使用更长的哈希来处理
- **当**读取文件时，**则**系统必须验证 frontmatter 结构并优雅地处理格式错误的文件
- **当**Git 操作失败时，**则**系统不得继续执行依赖于这些提交的文件系统操作

#### 8.3 错误处理

**验收标准**：
- **当**任何操作失败时，**则**系统必须提供清晰、可操作的错误消息
- **当**用户提供无效输入时，**则**系统必须验证输入并提供具体反馈
- **当**系统遇到意外错误时，**则**它必须适当地记录错误，而不暴露敏感信息
- **如果**缺少必需的文件或目录，**则**系统必须创建它或提供清晰的设置说明

---

### 9. 边界情况和特殊场景

#### 9.1 哈希冲突处理

**验收标准**：
- **如果**生成的短哈希已存在，**则**系统必须生成新哈希或扩展哈希长度
- **当**处理哈希冲突时，**则**系统必须确保新哈希也是唯一的
- **当**解决冲突时，**则**系统必须记录事件以供调试

#### 9.2 文件系统边界情况

**验收标准**：
- **如果**文件被移动到 MemoFlow 仓库外部，**则**系统必须检测到这一点并适当处理
- **如果**文件从文件系统中手动删除，**则**系统必须检测孤立的引用并处理它们
- **如果**Inbox 目录已满或无法访问，**则**系统必须提供清晰的错误消息
- **当**移动文件时，**如果**目标位置已包含同名文件，**则**系统必须处理冲突（重命名或拒绝）

#### 9.3 Git 集成边界情况

**验收标准**：
- **如果**未初始化 Git，**则**系统必须自动初始化它
- **如果**新操作开始时存在未提交的更改，**则**系统必须适当处理（警告、暂存或失败）
- **如果**Git push 失败（例如，网络问题），**则**系统不得使整个操作失败，但应记录问题
- **当**解析 Git 日志时，**如果**提交消息不遵循 Angular Convention，**则**系统必须优雅地处理它们

#### 9.4 Schema 演进

**验收标准**：
- **如果**修改 schema 且现有文件引用已删除的区域/类别，**则**系统必须适当处理这些文件
- **当**schema 更改时，**则**系统必须验证所有现有文件路径仍然有效或提供迁移指导
- **如果**schema 文件损坏，**则**系统必须回退到默认 schema 或提供恢复选项

---

## 成功标准

系统在以下情况下将被视为成功：

1. 用户可以在 5 秒内使用 `mf capture` 命令捕获内容
2. 用户可以仅使用短哈希移动和组织文件，而无需知道完整路径
3. 所有文件操作都自动在 Git 中跟踪，并带有有意义的提交消息
4. 系统提供清晰的状态和时间轴视图，帮助用户理解其工作流
5. 每日自动化工作流成功运行并生成有用的焦点和回顾文档
6. 即使文件被移动或重命名，系统也能保持数据完整性
7. 知识图谱同步准确表示文件关系，可以有效地进行查询
8. 系统优雅地处理边界情况，不会丢失或损坏数据
